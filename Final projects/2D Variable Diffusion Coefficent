
Content under Creative Commons Attribution license CC-BY 4.0, code under MIT license (c)2014 Louis Camacho.
2D Diffusion with Variable Diffusion Coefficent
Background
I hope everyone is ready for a new lesson! First a little background on what we are going to do. Since we already know what diffusion is, we know that after a certain amount of time and space the concentration of a substance will diminish into the surrounding area until there is equilibrium. Assumming we know what our initial conditions are, we can calculate the time elapsed.The diffusion coefficient is unique in every situation. It is measured at a particular temperature in a particualr medium for a particular material. Up until this point we have held the diffusion coefficent constant making our lives easy. Now its time to instill fear into our hearts and make everything harder, but not to worry when this over we will have a realisitic view on the world around us and have conquered our fears!
Alright lets jump right in. First a quick review of the diffusion in 2D: \begin{aligned} \frac{\partial{\mathbf{u}}}{\partial t} & = {\mathbf{v}} (\frac{\partial^2{\mathbf{u}}}{\partial{\mathbf{x^2}}}+\,\frac{\partial^2{\mathbf{u}}}{\partial{\mathbf{y^2}}}) \end{aligned}
The Problem
What if our silicon chip was defective, like if it contained several impurities like dust and other contaminants, this will definitely affect our diffusivity since it is no longer just silicone. What are looking to do is have the v vary through our experiment while in progress. To do that lets first setup our 2D equation as we have before.
In [109]:
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline
from matplotlib import rcParams
rcParams['font.family']='serif'
rcParams['font.size']=17
In [110]:
L = 1.0e-2
R = 1.0e-2

nx = 21
ny = 21
nt = 500

dx = L/(nx-1)
dy = R/(ny-1)

x = numpy.linspace(0,L,nx)
y = numpy.linspace(0,R,ny)


Ti = numpy.ones((ny, nx))*10
Ti[0,:]= 100
Ti[:,0] = 100
While we can use our code for foward time central space. We will have to play with it a little bit. The first time we have to do is what are we going to do with "V"? Well, before that we have ask ourselves what is going on inside the code. We could just slap on a numpy array with certain values and have the code run those values but look what happens:
In [111]:
vi=np.linspace(.0001,.0003,3) 
In [112]:
def fc(T, nt, vi, dt, dx, dy):

    j = (np.shape(T)[1])/2
    i = (np.shape(T)[0])/2
       
    for n in range(nt):
            
                
            Tn = T.copy()
            T[1:-1,1:-1] = Tn[1:-1,1:-1] + vi *\
                (dt/dx**2 * (Tn[1:-1,2:] - 2*Tn[1:-1,1:-1] + Tn[1:-1,:-2]) +\
                 dt/dy**2 * (Tn[2:,1:-1] - 2*Tn[1:-1,1:-1] + Tn[:-2,1:-1]))
  
            # Don't forget our Neumann BCs
            T[-1,:] = T[-2,:]
            T[:,-1] = T[:,-2]
        
    
            if T[j, i] >= 85:
                print ("Center of plate reached 85C at time {0:.2f}s.".format(dt*n))
                break
        
            if T[j, i]<85:
                print ("Center has not reached 85C yet, it is only {0:.2f}C.".format(T[j, i]))
        
        
In [113]:
sigma = 0.25
dt = sigma * min(dx, dy)**2 / vi
T=Ti.copy()
T = fc(T, nt, vi, dt, dx, dy)
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-113-559debbc663a> in <module>()
      2 dt = sigma * min(dx, dy)**2 / vi
      3 T=Ti.copy()
----> 4 T = fc(T, nt, vi, dt, dx, dy)

<ipython-input-112-b5be13e9e2cf> in fc(T, nt, vi, dt, dx, dy)
      8 
      9             Tn = T.copy()
---> 10             T[1:-1,1:-1] = Tn[1:-1,1:-1] + vi *                (dt/dx**2 * (Tn[1:-1,2:] - 2*Tn[1:-1,1:-1] + Tn[1:-1,:-2]) +                 dt/dy**2 * (Tn[2:,1:-1] - 2*Tn[1:-1,1:-1] + Tn[:-2,1:-1]))
     11 
     12             # Don't forget our Neumann BCs

ValueError: operands could not be broadcast together with shapes (3,) (19,19) 
The Solution
NOOOO! What happened!?
Well, what happened is that Python is using all values for v or vi (as we used it) and putting them in to the function and not refreshing T like we want. In other words, the first v is being used and taking up all the spaces, so that the rest of the v values are left out with no spaces from them.
So, how do we fix you say? First, we can use a for loop for v values before the n loop so that all v's are used. With that done we have to have a copy of that array both outside and inside the v loop. That way when the first value of v are used T can be cleared and ready for the next v value until the there are none left. Let's take a look:
In [114]:
def fc(T, nt, vi, dt, dx, dy):

    j = (np.shape(T)[1])/2
    i = (np.shape(T)[0])/2
    
     
    Ti=T.copy() #Copy blank T outside
    
    for vi in (v): #Our v loop
        T=Ti.copy() #Copy blank T inside
        dt = sigma * min(dx, dy)**2 / vi #Don't forget to move dt into the v loop, so that dt can also be updated with the new T!
       
        for n in range(nt):
            
                
            Tn = T.copy()
            T[1:-1,1:-1] = Tn[1:-1,1:-1] + vi *\
                (dt/dx**2 * (Tn[1:-1,2:] - 2*Tn[1:-1,1:-1] + Tn[1:-1,:-2]) +\
                 dt/dy**2 * (Tn[2:,1:-1] - 2*Tn[1:-1,1:-1] + Tn[:-2,1:-1]))
  
            # Don't forget our Neumann BCs
            T[-1,:] = T[-2,:]
            T[:,-1] = T[:,-2]
        
    
            if T[j, i] >= 85:
                print ("Center of plate reached 85C at time {0:.2f}s.".format(dt*n))
                break
        
        if T[j, i]<85:
            print ("Center has not reached 85C yet, it is only {0:.2f}C.".format(T[j, i]))
        
        
In [115]:
sigma = 0.25
T=Ti.copy()
T = fc(T, nt, vi, dt, dx, dy)
Center of plate reached 85C at time 0.31s.
Center of plate reached 85C at time 0.16s.
Center of plate reached 85C at time 0.10s.

Yes! We get our expected answers! The physics is correct the higher our diffusion coefficent the less time it takes to spread out. The fact that our code is telling us that our varying v has a profound effect on the solution is incredible. Basically, it is modeling something like, for example turbulence, albeit very miniscule, can effect any experiment. We now have the basis of any real world scenario ready to go!
Some Pics!
In [9]:
from IPython.display import Image
Image(url='http://mathbench.umd.edu/modules/cell-processes_diffusion/Finalgraphics/graph-flux-vs-gradient-rollover.gif')
Out[9]:

As this sophisticated graph shows that a higher D, v for us, the higher the slope and that less time is required for complete diffusion. Remember that our flux is dependant on our coefficent and steepness of the gradient as shown below: \begin{aligned} {\mathbf{flux}} = {\mathbf{-D}} (\frac{{\mathbf{Du}}}{{\mathbf{Dx}}}) \end{aligned}
So the amount of flux (rate of heat) moving through the chip is dependant on the coefficent which is not constant and the gradient. Causing the time to shift slow to fast and vice versa. If we wanted to we could have this go on until the chip fails, but we'll save that for another day.
Citations & Recongition (Shout Outs!):
(http://mathbench.umd.edu/modules/cell-processes_diffusion/page10.htm) University of Maryland, Mathbench
(Numerical MOOC Module 4 Lesson 4) George Washington University, Professor Lorena Barba & Gilbert Forsyth
(http://en.wikipedia.org/wiki/Fick%27s_laws_of_diffusion) Wiki Article, Wikipedia
In [10]:
from IPython.core.display import HTML
css_file = '../../styles/numericalmoocstyle.css'
HTML(open(css_file, "r").read())
---------------------------------------------------------------------------
IOError                                   Traceback (most recent call last)
<ipython-input-10-fde599084f9c> in <module>()
      1 from IPython.core.display import HTML
      2 css_file = '../../styles/numericalmoocstyle.css'
----> 3 HTML(open(css_file, "r").read())

IOError: [Errno 2] No such file or directory: '../../styles/numericalmoocstyle.css'
In []:
